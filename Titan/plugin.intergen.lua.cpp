
//@file  lua interface dispatcher generated by intergen v6
//See LICENSE file for copyright and license information

#include <comm/metastream/metastream.h>
#include <comm/metastream/fmtstream_lua_capi.h>
#include <comm/binstream/filestream.h>
#include <comm/binstream/binstreambuf.h>

#include "ifc/plugin_interface.lua.h"

using namespace coid;

////////////////////////////////////////////////////////////////////////////////
//
// lua handler of interface plugin_interface of class plugin
//
////////////////////////////////////////////////////////////////////////////////

namespace lua {

////////////////////////////////////////////////////////////////////////////////
///Interface declaration: [namespace::]name, path
class plugin_interface_lua_dispatcher
    : public ::lua::interface_wrapper_base<::plugin_interface>
{
protected:

    EBackend intergen_backend() const override { return IFC_BACKEND_LUA; }
    static const coid::token& lua_class_name() { static const coid::token _lua_class_name = "plugin_interface"; return _lua_class_name; };

public:

    iref<::lua::registry_handle> create_interface_object(bool make_weak);

    COIDNEWDELETE("plugin_interface_lua_dispatcher");

    plugin_interface_lua_dispatcher()
    {    }

    plugin_interface_lua_dispatcher(iref<::lua::registry_handle> context, plugin_interface* orig ) {
        _base.create(orig);
        _vtable = _base->vtable();

        _context->set_state(context->get_state());
        context->get_ref();
        _context->set_ref();

        _host = _base->host<policy_intrusive_base>();
    }

    ~plugin_interface_lua_dispatcher() {

    }
    
    bool intergen_bind_capture( coid::binstring* capture, uint instid ) override
    {
        return _real()->intergen_bind_capture(capture, instid);
    }

    void intergen_capture_dispatch( uint mid, coid::binstring& bin ) override
    {
        _real()->intergen_capture_dispatch(mid, bin);
    }

    // --- registrar ---
    /// expects context table on the top of the stack
    static int register_to_context_plugin_interface(lua_State * L);

    // --- creators ---

    ///Interface creator
    static iref<plugin_interface_lua_dispatcher> get(lua_State * L, const ::lua::script_handle& scriptpath, const coid::token& bindname, iref<::lua::registry_handle>* );

    static int luacreator_get0(lua_State * L, ::lua::interface_context* ifc);

    static int lualog_exc(lua_State * L);
    static int lualog(lua_State * L);
    static int luaquery_interface_exc(lua_State * L);
    static int luaquery_interface(lua_State * L);
    static int luarebind_events_exc(lua_State * L);
    static int luarebind_events(lua_State * L);


    // --- method wrappers ---

    static int lua_set_value0_exc( lua_State * L );
    static int lua_set_value0( lua_State * L );
    static bool can_use_ffi_set_value0();
    static void get_ffi_inject_set_value0(coid::token& header, coid::token& body);
    static void lua_set_value0_ffi(void * ifc_this, int x);
    static int lua_get_value1_exc( lua_State * L );
    static int lua_get_value1( lua_State * L );
    static bool can_use_ffi_get_value1();
    static void get_ffi_inject_get_value1(coid::token& header, coid::token& body);
    static int lua_get_value1_ffi(void * ifc_this);
};

////////////////////////////////////////////////////////////////////////////////
//
//  void plugin_interface::set_value( int x)
//
__declspec(noinline) int plugin_interface_lua_dispatcher::lua_set_value0_exc( lua_State * L )
{
    bool exception_thrown = false;

    try {
        const int args_count = lua_gettop(L) - 1;

        if (args_count < 1 || args_count > 1) { //in/inout arguments
            coid::charstr tmp = "Wrong number of arguments in ";
            tmp << "plugin_interface.set_value";
            throw coid::exception(tmp);
        }

        if (!lua_istable(L, 1) || !lua_hasfield(L, 1, ::lua::_lua_cthis_key)) {
            coid::charstr tmp = "Caller is not valid object in ";
            tmp << "plugin_interface.set_value";
            throw coid::exception(tmp);
        }

        lua_getfield(L, 1, ::lua::_lua_cthis_key);

        ::lua::interface_wrapper_base<::plugin_interface>* ifc = reinterpret_cast<::lua::interface_wrapper_base<::plugin_interface>*>(
        *static_cast<size_t*>(lua_touserdata(L, -1)));
        lua_pop(L, 1);

        auto R_ = ifc ? ifc->_real() : 0;
        if (!R_) {
            coid::charstr tmp = "Null interface object in ";
            tmp << "plugin_interface.set_value";
            throw coid::exception(tmp);
        }

        THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

        //stream the arguments in

        lua_pushvalue(L, 0 + 2);
        static_assert(CHECK::meta_operator_exists<int>::value, "missing metastream operator 'int'");
            threadcached<int> x;
        from_lua(x);

//out params

// invoke
        R_->set_value(x);
    
//stream out
        THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

        return 0;    }
    catch (coid::exception e) {
        lua_pushtoken(L, e.text());
        ::lua::catch_lua_error(L);
    }

    return -1;
}

int plugin_interface_lua_dispatcher::lua_set_value0( lua_State * L ){
    int res = lua_set_value0_exc(L);
    if (res == -1) {
        lua_error(L);
    }

    return res;
}

bool plugin_interface_lua_dispatcher::can_use_ffi_set_value0(){
    const MetaDesc * dsc = nullptr;

    dsc = coid::metastream::meta_find_type<int>();
    if(!dsc || !dsc->btype.is_plain())    return false;

    return true;
}

void plugin_interface_lua_dispatcher::get_ffi_inject_set_value0(coid::token& header, coid::token& body){
    static const coid::token h = "typedef void (*plugin_interface_set_value0_fun)(void * ifc_this, int x)\n";
    header = h;
    static const coid::token b =
"plugin_interface.set_value_ffi = ffi.cast(\"plugin_interface_set_value0_fun\",plugin_interface.set_value);\n"\
"function plugin_interface:set_value(x,)\n"\
"   return plugin_interface.set_value_ffi(self.__cthis, x)\n"\
"end;\n";
    body = b;
}
/*
void plugin_interface_lua_dispatcher::lua_set_value0_ffi(void * ifc_this, int x){

}
*/
////////////////////////////////////////////////////////////////////////////////
//
//  int plugin_interface::get_value()
//
__declspec(noinline) int plugin_interface_lua_dispatcher::lua_get_value1_exc( lua_State * L )
{
    bool exception_thrown = false;

    try {
        const int args_count = lua_gettop(L) - 1;

        if (args_count < 0 || args_count > 0) { //in/inout arguments
            coid::charstr tmp = "Wrong number of arguments in ";
            tmp << "plugin_interface.get_value";
            throw coid::exception(tmp);
        }

        if (!lua_istable(L, 1) || !lua_hasfield(L, 1, ::lua::_lua_cthis_key)) {
            coid::charstr tmp = "Caller is not valid object in ";
            tmp << "plugin_interface.get_value";
            throw coid::exception(tmp);
        }

        lua_getfield(L, 1, ::lua::_lua_cthis_key);

        ::lua::interface_wrapper_base<::plugin_interface>* ifc = reinterpret_cast<::lua::interface_wrapper_base<::plugin_interface>*>(
        *static_cast<size_t*>(lua_touserdata(L, -1)));
        lua_pop(L, 1);

        auto R_ = ifc ? ifc->_real() : 0;
        if (!R_) {
            coid::charstr tmp = "Null interface object in ";
            tmp << "plugin_interface.get_value";
            throw coid::exception(tmp);
        }

        THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

        //stream the arguments in

//out params

// invoke
        int _rval_ = R_->get_value();
    
//stream out
        THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

        static_assert(CHECK::meta_operator_exists<int>::value, "missing metastream operator for 'int'");
        to_lua(_rval_);
    
        return 1;
    }
    catch (coid::exception e) {
        lua_pushtoken(L, e.text());
        ::lua::catch_lua_error(L);
    }

    return -1;
}

int plugin_interface_lua_dispatcher::lua_get_value1( lua_State * L ){
    int res = lua_get_value1_exc(L);
    if (res == -1) {
        lua_error(L);
    }

    return res;
}

bool plugin_interface_lua_dispatcher::can_use_ffi_get_value1(){
    const MetaDesc * dsc = nullptr;

    return true;
}

void plugin_interface_lua_dispatcher::get_ffi_inject_get_value1(coid::token& header, coid::token& body){
    static const coid::token h = "typedef int (*plugin_interface_get_value1_fun)(void * ifc_this)\n";
    header = h;
    static const coid::token b =
"plugin_interface.get_value_ffi = ffi.cast(\"plugin_interface_get_value1_fun\",plugin_interface.get_value);\n"\
"function plugin_interface:get_value()\n"\
"   return plugin_interface.get_value_ffi(self.__cthis)\n"\
"end;\n";
    body = b;
}
/*
int plugin_interface_lua_dispatcher::lua_get_value1_ffi(void * ifc_this){

}
*/
////////////////////////////////////////////////////////////////////////////////
__declspec(noinline) int plugin_interface_lua_dispatcher::lualog_exc( lua_State * L )
{
    try {
        if (lua_gettop(L) == 0)
            return 0;

        const void* inst = 0;

        lua_insert(L, 1);

        if (lua_istable(L, -1) && lua_hasfield(L, -1, ::lua::_lua_cthis_key)) {
            lua_getfield(L, -1, ::lua::_lua_cthis_key);
            if (lua_isuserdata(L, -1)) {
                lua::plugin_interface_lua_dispatcher* ifc = reinterpret_cast<lua::plugin_interface_lua_dispatcher*>
                    (*static_cast<size_t*>(lua_touserdata(L, -1)));
                lua_pop(L, 1);

                inst = ifc;
                if (!ifc) {
                    throw coid::exception("Null interface object in log");
                }
            }

            lua_pop(L, 1);
        }

        intergen_interface::ifclog_ext(coid::ELogType::None, coid::tokenhash("plugin_interface"),
            inst, lua_totoken(L, -1));

        lua_pop(L, 1);

        return 0;
    }
    catch (coid::exception e) {
        lua_pushtoken(L, e.text());
        ::lua::catch_lua_error(L);
    }

    return -1;
}

////////////////////////////////////////////////////////////////////////////////
int plugin_interface_lua_dispatcher::lualog(lua_State * L) {
    int res = lualog_exc(L);
    if (res == -1) {
        lua_error(L);
    }

    return res;
}

////////////////////////////////////////////////////////////////////////////////
__declspec(noinline) int plugin_interface_lua_dispatcher::luaquery_interface_exc( lua_State * L )
{
    try {

        if (lua_gettop(L) < 2) {
            throw coid::exception("Interface creator name or caller object is missing.");
        }
        
        lua_pushbot(L); // move object table onto top of the stack

        if (!lua_istable(L, -1) || !lua_hasfield(L,-1, ::lua::_lua_cthis_key))
            return 0;

        lua_getfield(L, -1, ::lua::_lua_cthis_key);

        if (!lua_isuserdata(L,-1))
            return 0;

        lua::plugin_interface_lua_dispatcher* ifc = reinterpret_cast<lua::plugin_interface_lua_dispatcher*>
            (*static_cast<size_t*>(lua_touserdata(L,-1)));

        if (!ifc)
            throw coid::exception("Null interface object in query_interface");

        lua_pushbot(L); // move creator key onto top of the stack

        if (!lua_isstring(L, -1))
            throw coid::exception("Interface creator name missing.");

        coid::token tokey = lua_totoken(L, -1);

        typedef int(*fn_get)(lua_State * L, ::lua::interface_context*);
        fn_get get = reinterpret_cast<fn_get>(
            coid::interface_register::get_interface_creator(tokey));

        if (!get) {
            coid::charstr tmp = "interface creator ";
            tmp << tokey << " not found";
            throw coid::exception(tmp);
        }

        lua_pop(L, 3); // pop redundant data from stack

        get(L, ifc);
        return 1;
    }
    catch (coid::exception e) {
        lua_pushtoken(L, e.text());
        ::lua::catch_lua_error(L);
    }

    return -1;
}

int plugin_interface_lua_dispatcher::luaquery_interface(lua_State * L) {
    int res = luaquery_interface_exc(L);
    if (res == -1) {
        lua_error(L);
    }

    return res;
}


////////////////////////////////////////////////////////////////////////////////
_declspec(noinline) int plugin_interface_lua_dispatcher::luarebind_events_exc( lua_State * L )
{
    return 0;
}

int plugin_interface_lua_dispatcher::luarebind_events(lua_State * L) {
    int res = luarebind_events_exc(L);
    if (res == -1) {
        lua_error(L);
    }

    return res;
}

////////////////////////////////////////////////////////////////////////////////
iref<::lua::registry_handle> plugin_interface_lua_dispatcher::create_interface_object( bool make_weak )
{
    lua_State * L = _context->get_state();
    _context->get_ref();
    if (!lua_hasfield(L, -1, lua_class_name()))
    {
        register_to_context_plugin_interface(L);
    }
    lua_pop(L, 1);

    lua_createtable(L, 0, 3);
    lua_pushvalue(L, -1);
    lua_setmetatable(L, -2);

    void * cptr_holder = lua_newuserdata(L, sizeof(size_t));
    *static_cast<size_t*>(cptr_holder) = reinterpret_cast<size_t>(this);
    lua_setfield(L, -2, ::lua::_lua_cthis_key);
        
    lua_pushnumber(L, ints(1320019967));
    lua_setfield(L, -2, ::lua::_lua_class_hash_key);

    _context->get_ref();
    lua_getfield(L, -1, lua_class_name());
    lua_setfield(L, -3, ::lua::_lua_parent_index_key);
    lua_pop(L, 1);

    iref<::lua::registry_handle> obj;

    if (make_weak) {
        obj = new ::lua::weak_registry_handle(L);
        lua_getfield(L, -1, ::lua::_lua_cthis_key);
        lua_rawgeti(L, LUA_REGISTRYINDEX, ::lua::LUA_WEAK_IFC_MT_INDEX);
        lua_setmetatable(L,-2);
        lua_pop(L, 1);
        add_refcount();
    }
    else {
        obj = new ::lua::registry_handle(L);
    }

    obj->set_ref();
    return obj;
}


// --- registrar ---
int plugin_interface_lua_dispatcher::register_to_context_plugin_interface(lua_State * L) {
    //lua_getglobal(L, ::lua::_lua_class_register_key);

   // if (lua_isnil(L, -1)) {
   //     throw coid::exception() << "Given lua_State is not valid!(use lua_state_wrapper to create valid lua_State)";
  //  }

    //const uint methods_count =2 

    lua_createtable(L, 0, 0);

    lua_pushcfunction(L, &plugin_interface_lua_dispatcher::lualog);
    lua_setfield(L, -2, ::lua::_lua_log_key);

    lua_pushcfunction(L, &plugin_interface_lua_dispatcher::luaquery_interface);
    lua_setfield(L, -2, ::lua::_lua_query_interface_key);

    lua_pushcfunction(L, &plugin_interface_lua_dispatcher::lua_set_value0);
    lua_setfield(L, -2, "set_value");

    lua_pushcfunction(L, &plugin_interface_lua_dispatcher::lua_get_value1);
    lua_setfield(L, -2, "get_value");

    lua_setfield(L, -2, lua_class_name());
    
    return 0;
}

// --- creators ---

////////////////////////////////////////////////////////////////////////////////
iref<plugin_interface_lua_dispatcher> plugin_interface_lua_dispatcher::get(lua_State * L, const ::lua::script_handle& script, const coid::token& bindname, iref<::lua::registry_handle>* ctx )
{
    // create interface object
    iref<plugin_interface_lua_dispatcher> ifc = plugin_interface::get(new plugin_interface_lua_dispatcher);
    if (!ifc)
        throw coid::exception() << "failed to create interface object";

    iref<::lua::registry_handle> context = nullptr;

    if (script.has_context()){
        context = script.context();
    }
    else {
        context = new ::lua::lua_context(L);

        if (script.is_path()) {
            coid::token script_info;
            script_info = script.str();
            if (script_info.contains_back('\\') || script_info.contains_back('/')) {
                script_info.cut_left_group_back(coid::DIR_SEPARATORS);
            }
            context->get_ref();
            lua_pushtoken(L, script_info);
            lua_setfield(L, -2, ::lua::_lua_context_info_key);
            lua_pop(L, 1);
        }
    }

    if (ctx)
        *ctx = context;

    if (!script.is_context())
    {
        coid::token script_tok;
        coid::charstr script_tmp;
        if (script.is_path()) {
            coid::bifstream bif(script.str());
            if (!bif.is_open())
                throw coid::exception() << script.str() << " not found";

            script_tmp = script.prefix();

            coid::binstreambuf buf;
            buf.swap(script_tmp);
            buf.transfer_from(bif);
            buf.swap(script_tmp);

            script_tok = script_tmp;
        }
        else if (script.prefix()) {
            script_tmp << script.prefix() << script.str();
            script_tok = script_tmp;
        }
        else {
            script_tok = script.str();
        }

        ::lua::load_script(context, script_tok, script.url());
    }
    
    ifc->_context = new ::lua::weak_registry_handle(L);
    context->get_ref();
    ifc->_context->set_ref();
    ifc->_object = ifc->create_interface_object(false);

    if (bindname) {
        context->get_ref();
        ifc->_object->get_ref();
        lua_setfield(L, -2, bindname);
        lua_pop(L, 1);
    }
    
    return ifc;
}

////////////////////////////////////////////////////////////////////////////////
///Creator methods for access from LUA
///
///  iref<plugin_interface> plugin_interface::get()
///

int plugin_interface_lua_dispatcher::luacreator_get0(lua_State * L, ::lua::interface_context* ifc )
{
    const int args_count = lua_gettop(L);

    if (args_count < 0 || args_count > 0) { //in/inout arguments
        coid::charstr tmp = "Wrong number of arguments in ";
        tmp << "plugin_interface.get";
        throw coid::exception(tmp);
    }

    //stream the arguments in
    THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

//out params
    iref<plugin_interface_lua_dispatcher> nifc = plugin_interface::get(new plugin_interface_lua_dispatcher);

    //stream out
    if (nifc) {
        if (ifc) {
            nifc->_context = ifc->_context;
        }
        else {
            nifc->_context->set_state(L);
            lua_pushvalue(L, LUA_ENVIRONINDEX);
            nifc->_context->set_ref();
        }

        nifc->create_interface_object(true)->get_ref();
    }
    else {
        lua_pushnil(L);
    }

    return 1;
}

////////////////////////////////////////////////////////////////////////////////
///Create LUA wrapper from an existing interface object
iref <::lua::registry_handle> create_wrapper_plugin_interface(::plugin_interface* orig, iref<::lua::registry_handle> context)
{
    // check that the orig points to an object
    if (!orig) return nullptr;

    iref<lua::plugin_interface_lua_dispatcher> ifc;
    iref <::lua::registry_handle> obj;

    if (orig->intergen_backend() == intergen_interface::IFC_BACKEND_LUA)
        obj = static_cast<plugin_interface_lua_dispatcher*>(orig)->_object;
    
    if (obj.is_empty()) {
        // create interface object
        ifc.create(new lua::plugin_interface_lua_dispatcher(context, static_cast<::plugin_interface*>(orig)));

        obj = ifc->create_interface_object(true);
    }

    return obj;
}

////////////////////////////////////////////////////////////////////////////////
static void register_binders_for_plugin_interface( bool on )
{
    interface_register::register_interface_creator(
        "lua::register_class.plugin_interface",
        on ? (void*)&plugin_interface_lua_dispatcher::register_to_context_plugin_interface
        : nullptr);

    interface_register::register_interface_creator(
        "plugin_interface.get@creator.lua",
        on ? (void*)&plugin_interface_lua_dispatcher::get : nullptr);
    interface_register::register_interface_creator(
        "lua::plugin_interface.get",
        on ? (void*)&plugin_interface_lua_dispatcher::luacreator_get0 : nullptr);
    interface_register::register_interface_creator(
        "plugin_interface@wrapper.lua",
        on ? (void*)&create_wrapper_plugin_interface : nullptr);

}

//auto-register the bind function
LOCAL_SINGLETON_DEF(ifc_autoregger) plugin_interface_autoregger = new ifc_autoregger(&register_binders_for_plugin_interface);

void* force_register_plugin_interface() {
    LOCAL_SINGLETON_DEF(ifc_autoregger) autoregger = new ifc_autoregger(&register_binders_for_plugin_interface);
    return autoregger.get();
}

} //namespace lua

