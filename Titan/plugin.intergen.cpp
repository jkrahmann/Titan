
//@file  interface dispatcher generated by intergen v6
//See LICENSE file for copyright and license information

#include "ifc/plugin_interface.h"
#include "plugin.hpp"

#include <comm/ref.h>
#include <comm/singleton.h>
#include <comm/binstring.h>
#include <type_traits>


static_assert(intergen_interface::VERSION == 6, "interface must be rebuilt with a different intergen version");

using namespace coid;

static_assert( std::is_base_of<policy_intrusive_base, plugin>::value, "class 'plugin' must be derived from policy_intrusive_base");
static_assert( std::is_base_of<policy_intrusive_base, plugin>::value, "class 'plugin' must be derived from policy_intrusive_base");

////////////////////////////////////////////////////////////////////////////////
// interface plugin_interface of class plugin


///
class plugin_interface_dispatcher : public plugin_interface
{
private:

    static coid::binstring* _capture;
    static uint16 _instid;
    static ifn_t* _vtable1;
    static ifn_t* _vtable2;

    static ifn_t* get_vtable()
    {
        if (_vtable1) return _vtable1;

        _vtable1 = new ifn_t[2];
        _vtable1[0] = reinterpret_cast<ifn_t>(static_cast<void(policy_intrusive_base::*)(int)>(&::plugin::set_value));
        _vtable1[1] = reinterpret_cast<ifn_t>(static_cast<int(policy_intrusive_base::*)()const>(&::plugin::get_value));
        return _vtable1;
    }

    #define VT_CALL2(R,F,I) ((*reinterpret_cast<policy_intrusive_base*>(this)).*(reinterpret_cast<R(policy_intrusive_base::*)F>(_vtable1[I])))


    static ifn_t* get_vtable_intercept()
    {
        if (_vtable2) return _vtable2;
        ifn_t* vtable1 = get_vtable();

        _vtable2 = new ifn_t[2];
        _vtable2[0] = vtable1[0];
        _vtable2[1] = vtable1[1];
        return _vtable2;
    }

protected:

    COIDNEWDELETE("plugin_interface_dispatcher");

    plugin_interface_dispatcher()
    {}

    bool intergen_bind_capture( coid::binstring* capture, uint instid ) override
    {
        if (instid >= 0xffU)
            return false;

        _instid = uint16(instid << 8U);
        _capture = capture;
        _vtable = _capture ? get_vtable_intercept() : get_vtable();
        return true;
    }

    void intergen_capture_dispatch( uint mid, coid::binstring& bin ) override
    {
        switch(mid) {
        case UMAX32:
        default: throw coid::exception("unknown method id in plugin_interface capture dispatcher");
        }
    }

    static iref<plugin_interface> _generic_interface_creator( ::plugin* host, plugin_interface* __here__)
    {
        //cast to dispatch to sidestep protected access restrictions
        plugin_interface_dispatcher* __disp__ = static_cast<plugin_interface_dispatcher*>(__here__);
        if (!__disp__)
            __disp__ = new plugin_interface_dispatcher;

        __disp__->_host.create(host);
        __disp__->_vtable = _capture ? get_vtable_intercept() : get_vtable();

        return __disp__;
    }

public:

    // creator methods

    static iref<plugin_interface> get( plugin_interface* __here__ )
    {
        iref< ::plugin> __host__ = ::plugin::get();
        if (!__host__)
            return 0;
        return _generic_interface_creator(__host__.get(), __here__);
    }

    ///Register interface creators in the global registry
    static void register_interfaces( bool on )
    {
        interface_register::register_interface_creator(
            "plugin_interface@wrapper",
            on ? (void*)&_generic_interface_creator : nullptr);

        interface_register::register_interface_creator(
            "plugin_interface.get@1320019967",
            on ? (void*)&get : nullptr);
    }
};

coid::binstring* plugin_interface_dispatcher::_capture = 0;
uint16 plugin_interface_dispatcher::_instid = 0xffffU;
intergen_interface::ifn_t* plugin_interface_dispatcher::_vtable2 = 0;
intergen_interface::ifn_t* plugin_interface_dispatcher::_vtable1 = 0;


//auto-register the available interface creators
LOCAL_SINGLETON_DEF(ifc_autoregger) plugin_interface_autoregger = new ifc_autoregger(&plugin_interface_dispatcher::register_interfaces);

void* force_register_plugin_interface() {
    LOCAL_SINGLETON_DEF(ifc_autoregger) autoregger = new ifc_autoregger(&plugin_interface_dispatcher::register_interfaces);
    return autoregger.get();
}


